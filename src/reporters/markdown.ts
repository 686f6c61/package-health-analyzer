/**
 * package-health-analyzer - Markdown Reporter
 *
 * This module generates GitHub-flavored Markdown output optimized for documentation, pull requests,
 * and wiki pages. Users choose this format when embedding scan results in README files, generating
 * automated PR comments, or creating shareable documentation that renders beautifully on GitHub,
 * GitLab, and other Markdown-aware platforms with emoji support and table formatting.
 *
 * Key responsibilities:
 * - Rendering scan results as GitHub-flavored Markdown with emoji indicators
 * - Creating formatted tables for package details with sortable columns
 * - Generating PR-ready reports for automated dependency health comments
 * - Supporting documentation embedding in README.md and wiki pages
 * - Providing visual health indicators using emoji for quick at-a-glance status
 *
 * @module reporters/markdown
 * @author 686f6c61 <https://github.com/686f6c61>
 * @repository https://github.com/686f6c61/package-health-analyzer
 * @license MIT
 */

import type { ScanResult } from '../types/index.js';

export function formatMarkdownOutput(result: ScanResult): string {
  const lines: string[] = [];

  lines.push(`# Package Health Report`);
  lines.push('');
  lines.push(`**Project:** ${result.project.name}@${result.project.version}`);
  lines.push(`**Generated:** ${new Date().toISOString()}`);
  lines.push('');

  lines.push(`## Summary`);
  lines.push('');
  lines.push(`- **Total Packages:** ${result.summary.total}`);
  lines.push(`- **Average Score:** ${result.summary.averageScore.toFixed(1)}/100`);
  lines.push(`- **Risk Level:** ${getRiskEmoji(result.summary.riskLevel)} ${result.summary.riskLevel.toUpperCase()}`);
  lines.push('');

  if (result.treeSummary) {
    lines.push(`### Dependency Tree`);
    lines.push('');
    lines.push(`- **Total Nodes:** ${result.treeSummary.totalNodes}`);
    lines.push(`- **Unique Packages:** ${result.treeSummary.uniquePackages}`);
    lines.push(`- **Max Depth:** ${result.treeSummary.maxDepth}`);
    lines.push(`- **Circular Dependencies:** ${result.treeSummary.circularDependencies}`);
    lines.push(`- **Duplicate Packages:** ${result.treeSummary.duplicatePackages}`);
    lines.push('');
  }

  lines.push(`## Package Details`);
  lines.push('');
  lines.push(`| Package | Version | Score | License | Age | Deprecated |`);
  lines.push(`|---------|---------|-------|---------|-----|------------|`);

  for (const pkg of result.packages) {
    const scoreValue = typeof pkg.score === 'object' ? pkg.score.overall : pkg.score;
    const score = scoreValue !== undefined ? `${getScoreEmoji(scoreValue)} ${scoreValue.toFixed(0)}` : 'N/A';
    const deprecated = pkg.age?.deprecated ? 'âš ï¸ Yes' : 'âœ… No';
    const ageHuman = pkg.age?.ageHuman || 'Unknown';

    lines.push(`| ${pkg.package} | ${pkg.version} | ${score} | ${pkg.license?.license || 'Unknown'} | ${ageHuman} | ${deprecated} |`);
  }

  lines.push('');

  if (result.summary.severityCounts && Object.keys(result.summary.severityCounts).length > 0) {
    lines.push(`## Issues by Severity`);
    lines.push('');
    for (const [severity, count] of Object.entries(result.summary.severityCounts)) {
      if (count > 0) {
        lines.push(`- **${severity.toUpperCase()}:** ${count}`);
      }
    }
    lines.push('');
  }

  lines.push(`---`);
  lines.push(`*Generated by package-health-analyzer v2.0.0*`);
  lines.push('');

  return lines.join('\n');
}

function getScoreEmoji(score: number): string {
  if (score >= 80) return 'ğŸŸ¢';
  if (score >= 60) return 'ğŸ”µ';
  if (score >= 40) return 'ğŸŸ¡';
  return 'ğŸ”´';
}

function getRiskEmoji(risk: string): string {
  switch (risk) {
    case 'low': return 'âœ…';
    case 'medium': return 'âš ï¸';
    case 'high': return 'ğŸ”¶';
    case 'critical': return 'ğŸ”´';
    default: return '';
  }
}
